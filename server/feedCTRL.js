//DB schema config:
var feed = require('./feed'),
    member = require('./member'), 
    request = require('request'),
    async = require("async");
// var request = require('sync-request');

var urlSet = [
            //'shoa'  :
            'http://kikar.org/api/v1/facebook_status/?limit=1000&feed__is_current=true&content__contains=%D7%A9%D7%95%D7%90%D7%94&published__gte=2017-01-01',
            //'antis' : 
            'http://kikar.org/api/v1/facebook_status/?limit=100&feed__is_current=true&content__contains=%D7%90%D7%A0%D7%98%D7%99%D7%A9%D7%9E%D7%99&published__gte=2017-01-01',
            //'nazi'  : 
            'http://kikar.org/api/v1/facebook_status/?limit=100&feed__is_current=true&content__contains=%D7%A0%D7%90%D7%A6%D7%99&published__gte=2017-01-01',
            //'hitler'  : 
            'http://kikar.org/api/v1/facebook_status/?limit=100&feed__is_current=true&content__contains=%D7%94%D7%99%D7%98%D7%9C%D7%A8&published__gte=2017-01-01'
            ];

var data1 = [],
    data2=[],
    Img='1',
    urlImg='',
    _elm,
    imgArray= [];

// async.waterfall([
//     loadNewData,
//     default,
// ], function (err, result) {
//     // result now equals 'done'
// });
// function myFirstFunction(callback) {
//     callback(null, 'one', 'two');
// }
// function mySecondFunction(arg1, arg2, callback) {
//     // arg1 now equals 'one' and arg2 now equals 'two'
//     callback(null, 'three');
// }
// function myLastFunction(arg1, callback) {
//     // arg1 now equals 'three'
//     callback(null, 'done');
// }

exports.loadNewData = function(req, res){  
    var body =''
    urlSet.forEach(function(url, i){
        request(url, function (error, response, _body){
            if (!error && response.statusCode == 200){
                body+=_body;
                console.log('***done: '+i+'***');
                data1[i]=JSON.parse(_body);
                buildMembersDB(data1[i]);
            }
            else{
                console.log(error);
            }
        });
    });
}

function buildMembersDB(d){
    d.objects.forEach(function(f){
        urlImg='http://kikar.org'+f.feed;
        request(urlImg, function (error, response, elm){
            if (!error && response.statusCode == 200){   
                elm = JSON.parse(elm);
                imgArray.push({'id':elm.id, 'name':elm.name,'pic':elm.picture_large});
            }
            else{
                Img="error";
                console.log("*error*--> doc already in DB!");
            }
        }) 
    })
} 

exports.default = function(req, res, next){
    var temp={}, 
        key=' ',
        J_elm;

    data1.forEach(function(obj, i){
        obj.objects.forEach(function(field){
            key=String(i);
            if(i==0) key="שואה";
            else if(i==1) key="אנטישמיות";
            else if(i==2) key="נאצי";
            else if(i==3) key="היטלר";
            
            var max=' ',
                str=field.content;

            str= str.split(" ");
            for(var f=0; f<str.length; f++){
                str[f] = str[f].trim();
                str[f] = str[f].split('.').join("");
                str[f] = str[f].split(',').join("");
            }

                var stopList=["-","על","אם", "\n","את","של" ,"כי","תא" ,"or","for","if","with","to","of","הוא" ,"?" ,"היא" ,"לא", "כן","", "," , "the" , "и" , "в" , "או"],
                index=-1,
                indexes = [],
                p=-1;

            for (var k=0; k<stopList.length; k++){
                p = -1;
                while ((p = str.indexOf(stopList[k], p+1)) != -1){   
                    str.splice(p, 1);
                    p=p-1;
                }
            }
            max=common_word(str);
            updateDB(field, feed, max, key);
        }); //close obj.objects
    }); //close data1.foreach
    res.json(data2);
};

function updateDB(field, feed, max, key){
    if (field['has_attachment'] ==null){
        temp={
            "feed":field.feed,
            "memberID":(field.feed).substring(22, (field.feed).length-1),
            "content": field.content,
            "content_snippet": field.content_snippet,
            "facebook_link": field.facebook_link,
            "has_attachment": false,
            "id": field.id,
            "like_count": field.like_count,
            "member": field.member,
            "party": field.party,
            "published": field.published,
            "max_str": max,
            "key_word" : key
            };
           data2.push(temp);
           console.log(temp['memberID']);
    }
    else{
        temp={
            "attachment":{
                "is_photo": field.attachment.is_photo,
                "link:": field.attachment.link,
                "name": field.attachment.name,
                "picture": field.attachment.picture,
                "source": field.attachment.source,
            },
            "feed":field.feed,
            "memberID":(field.feed).substring(22, (field.feed).length-1),
            "content": field.content,
            "content_snippet": field.content_snippet,
            "facebook_link": field.facebook_link,
            "has_attachment": field.has_attachment,
            "id": field.id,
            "like_count": field.like_count,
            "member": field.member,
            "party": field.party,
            "published": field.published,
            "max_str": max,
            "key_word" : key
        };
        data2.push(temp);
        console.log(temp['memberID']);
    }
    feed.collection.update({"id": field.id}, temp, {upsert: true}, function(err, records){
        console.log("Record added as: "+field.id);
    });       

}

exports.updateMemberDB = function(req, res){
    imgArray.forEach(function(obj){
        console.log(obj);
        if(obj.pic != 'error'){
            member.collection.update({"id": obj.id}, obj, {upsert: true}, function(err, records){
            console.log("Record added as: "+obj.id , obj.pic);
            });
        } 
    }); 
    //JSON indicatore:
    var query = member.find({});
    query.exec(function(err, data) {
        if (err) return res.send(err);
            res.status(200).json(data);
        console.log(data);
    });
}

exports.getFeedsByID = function(req, res){
    var query = feed.find({memberID:req.params.memberID});
    query.exec(function(err, data) {
        if (err) return res.send(err);
            res.status(200).json(data);
        console.log('getFeedsByID');
    });

};

exports.getPicByID = function(req, res){
    var query = member.find({id:req.params.memberID});
    query.exec(function(err, data) {
        if (err) return res.send(err);
            res.status(200).json(data);
        console.log('getPicByID');
    });

};

exports.getAllFeeds = function(req, res){
    var query = feed.find({});
    query.exec(function(err, data) {
        if (err) return res.send(err);
            res.status(200).json(data);
        console.log('getAllFeeds');
    });

};

exports.getAllFeedsGrouped = function(req, res){
    query = feed.aggregate( 
    {
        $group: {
            _id: { name: "$member" ,id: "$memberID"},
            totalLikes: { $sum: "$like_count" },
            totalFeeds: { $sum: 1 },
        } 
    },
    function(err, data){
        if (err) return res.send(err);
        async.each(data,function(m,callback){
            feed.find({memberID:m._id.id},function(err,d){
                m.docs = d;
                callback();
            })
        }, 
        function(err){
            if( err ) {
                console.log('Failed to process');
            } else {
                console.log('All files have been processed successfully');
                console.log('getAllFeedsPerMem');
                res.json(data);
            }
        })
    })
};

exports.getFeedsFromTo = function(req, res){
    var query = feed.find({published: {$gte: req.params.from , $lte: req.params.to }});
    query.exec(function(err, data) {
        if (err) return res.send(err);
            res.status(200).json(data);
        console.log('getFeedsFromTo');
    });

};

exports.getFeedsFromToPerMember = function(req, res){
    query = feed.aggregate([
    {
        $match:{
            published: {$gte:req.params.from , $lte: req.params.to }
        }
    },
    {
        $group: {
            _id: { name: "$member" ,id: "$memberID"},
            totalLikes: { $sum: "$like_count" },
            totalFeeds: { $sum: 1 },
        } 
    }],
    function(err, data){
        if (err) return res.send(err);
        async.each(data,function(m,callback){
            feed.find({memberID:m._id.id , published: {$gte: req.params.from , $lte: req.params.to }},function(err,d){
                m.docs = d;
                callback();
            })
        }, 
        function(err){
            if( err ) {
                console.log('Failed to process');
            } else {
                console.log('All files have been processed successfully');
                console.log('getFeedsFromToPerMem');    
                res.json(data);
            }
        })
    })
};

exports.getAllMembers = function(req, res){
    var j1, j2;
    feed.aggregate(
       [
         {
           $group:
            {
                _id: { name: "$member", id: "$memberID" },
                totalLikes: { $sum: "$like_count" },
                totalFeeds: { $sum: 1 }
            }
         },
         {$sort: {totalFeeds:-1}}
       ],
    function(err, data){
        if (err) return res.send(err);
        async.each(data,function(m,callback){
            member.find({id:m._id.id},function(err,d){
                m.pic = d[0].pic;
                // console.log(m.pic);
                callback();
            })
        }, 
        function(err){
            if( err ) {
                console.log('Failed to process');
            } else {
              console.log('All files have been processed successfully');
              res.json(data);
            }
        })
    });
};

function common_word(array){
    if(array.length == 0)
        return null;
    var modeMap = {};
    var maxEl = array[0], maxCount = 1;
    for(var i = 0; i < array.length; i++){
        var el = array[i];
        if(modeMap[el] == null)
            modeMap[el] = 1;
        else
            modeMap[el]++;  
        if(modeMap[el] > maxCount ){
            maxEl = el;
            maxCount = modeMap[el];
        }
    }
    return maxEl;
}
